{"version":3,"file":"index.js","sources":["../src/http.ts"],"sourcesContent":["export const DEFAULT_BUFFER_SIZE = 4096;\n\nexport const HEADER_REGEX = /^([^: \\t]+):[ \\t]*((?:.*[^ \\t])|)/;\nexport const HEADER_CONTINUE_REGEX = /^[ \\t]+(.*[^ \\t])/;\nexport const REQUEST_REGEX = /^([A-Z-]+) ([^ ]+) HTTP\\/(\\d)\\.(\\d)$/;\nexport const RESPONSE_REGEX = /^HTTP\\/(\\d)\\.(\\d) (\\d{3}) ?(.*)$/;\n\nexport const NEWLINE = \"\\n\".charCodeAt(0);\nexport const RETURN = \"\\r\".charCodeAt(0);\n\nexport const TEXT_ENCODER = new TextEncoder();\nexport const TEXT_DECODER = new TextDecoder();\n\nexport class HTTPRequest extends Request {\n\tconstructor(input: RequestInfo | URL, init?: RequestInit) {\n\t\tconst headersInit = init?.headers;\n\t\tsuper(input, init);\n\t\tif (headersInit) {\n\t\t\tconst headers = new Headers(headersInit);\n\t\t\tObject.defineProperty(this, \"headers\", {\n\t\t\t\tvalue: headers,\n\t\t\t\twritable: false,\n\t\t\t});\n\t\t}\n\t}\n}\n\nexport async function parseRequest(\n\treader: ReadableStreamDefaultReader<Uint8Array>,\n\tinit: RequestInit = {\n\t\tmode: \"same-origin\",\n\t\tcredentials: \"include\",\n\t},\n): Promise<Request> {\n\tconst textReader = createTextReader(reader);\n\tconst [method, url] = await readRequestStartLine(textReader);\n\tconst [headers, chunked, contentLength] = await readHeaders(textReader);\n\tconst body = streamBody(textReader, chunked, contentLength);\n\treturn new HTTPRequest(url, {\n\t\t...init,\n\t\tmethod,\n\t\theaders,\n\t\tbody,\n\t\t// @ts-expect-error\n\t\tduplex: \"half\",\n\t});\n}\n\nexport async function parseResponse(\n\treader: ReadableStreamDefaultReader<Uint8Array>,\n) {\n\tconst textReader = createTextReader(reader);\n\tconst [statusCode, statusText] = await readResponseStartLine(textReader);\n\tconst [headers, chunked, contentLength] = await readHeaders(textReader);\n\tconst body = streamBody(textReader, chunked, contentLength);\n\treturn new Response(body, {\n\t\tstatus: statusCode,\n\t\tstatusText: statusText,\n\t\theaders,\n\t});\n}\n\nexport async function writeRequestOrResponse(\n\twritableStream: WritableStream<Uint8Array>,\n\trequestOrResponse: Request | Response,\n) {\n\tconst writer = writableStream.getWriter();\n\tlet closed = false;\n\ttry {\n\t\tconst [request, response] =\n\t\t\trequestOrResponse instanceof Request\n\t\t\t\t? [requestOrResponse, null]\n\t\t\t\t: [null, requestOrResponse];\n\t\tif (request) {\n\t\t\tawait writer.write(\n\t\t\t\tTEXT_ENCODER.encode(`${request.method} ${request.url} HTTP/1.1\\r\\n`),\n\t\t\t);\n\t\t} else {\n\t\t\tawait writer.write(\n\t\t\t\tTEXT_ENCODER.encode(\n\t\t\t\t\t`HTTP/1.1 ${response.status} ${response.statusText}\\r\\n`,\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\t\tconst headers = new Headers(requestOrResponse.headers) as Headers & {\n\t\t\tentries(): IterableIterator<[string, string]>;\n\t\t};\n\t\tif (requestOrResponse.body) {\n\t\t\tif (request) {\n\t\t\t\tconst body = await readAll(requestOrResponse.body.getReader());\n\n\t\t\t\theaders.set(\"Content-Length\", `${body.byteLength}`);\n\n\t\t\t\tfor (const [key, value] of headers.entries()) {\n\t\t\t\t\tawait writer.write(TEXT_ENCODER.encode(`${key}: ${value}\\r\\n`));\n\t\t\t\t}\n\t\t\t\tawait writer.write(TEXT_ENCODER.encode(\"\\r\\n\"));\n\t\t\t\tawait writer.write(body);\n\t\t\t} else {\n\t\t\t\tconst contentLength = Number.parseInt(\n\t\t\t\t\theaders.get(\"Content-Length\") || \"0\",\n\t\t\t\t\t10,\n\t\t\t\t);\n\t\t\t\tconst chunked =\n\t\t\t\t\theaders.get(\"Transfer-Encoding\")?.toLowerCase() === \"chunked\";\n\n\t\t\t\tfor (const [key, value] of headers.entries()) {\n\t\t\t\t\tawait writer.write(TEXT_ENCODER.encode(`${key}: ${value}\\r\\n`));\n\t\t\t\t}\n\t\t\t\tawait writer.write(TEXT_ENCODER.encode(\"\\r\\n\"));\n\t\t\t\twriter.releaseLock();\n\n\t\t\t\tawait streamBody(\n\t\t\t\t\tcreateTextReader(requestOrResponse.body.getReader()),\n\t\t\t\t\tchunked,\n\t\t\t\t\tcontentLength,\n\t\t\t\t)?.pipeTo(writableStream);\n\n\t\t\t\tclosed = true;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const [key, value] of headers.entries()) {\n\t\t\t\tawait writer.write(TEXT_ENCODER.encode(`${key}: ${value}\\r\\n`));\n\t\t\t}\n\t\t\tawait writer.write(TEXT_ENCODER.encode(\"\\r\\n\"));\n\t\t}\n\t} finally {\n\t\tif (!closed) {\n\t\t\twriter.releaseLock();\n\t\t\twritableStream.close();\n\t\t}\n\t}\n}\n\nasync function readRequestStartLine(\n\treader: TextReader,\n): Promise<\n\t[method: string, url: string, versionMajor: number, versionMinor: number]\n> {\n\tconst { done, value: startLine } = await reader.readLine();\n\tif (done) {\n\t\tthrow new Error(\"Unexpected end of request\");\n\t}\n\tconst match = REQUEST_REGEX.exec(startLine);\n\tif (!match) {\n\t\tthrow new Error(`Invalid request line: ${startLine}`);\n\t}\n\treturn [match[1], match[2], +match[3], +match[4]];\n}\n\nasync function readResponseStartLine(\n\treader: TextReader,\n): Promise<\n\t[\n\t\tstatusCode: number,\n\t\tstatusText: string,\n\t\tversionMajor: number,\n\t\tversionMinor: number,\n\t]\n> {\n\tconst { done, value: startLine } = await reader.readLine();\n\tif (done) {\n\t\tthrow new Error(\"Unexpected end of request\");\n\t}\n\tconst match = RESPONSE_REGEX.exec(startLine);\n\tif (!match) {\n\t\tthrow new Error(`Invalid response line: ${startLine}`);\n\t}\n\treturn [+match[3], match[4], +match[1], +match[2]];\n}\n\nasync function readHeaders(\n\treader: TextReader,\n): Promise<[headers: Headers, chunked: boolean, contentLength: number]> {\n\tconst headers = new Headers();\n\tlet chunked = false;\n\tlet contentLength = 0;\n\twhile (true) {\n\t\tconst { done, value: line } = await reader.readLine();\n\t\tif (done) {\n\t\t\tthrow new Error(\"Unexpected end of headers\");\n\t\t}\n\t\tif (line === \"\") {\n\t\t\tbreak;\n\t\t}\n\t\tconst match = HEADER_REGEX.exec(line);\n\t\tif (!match) {\n\t\t\tthrow new Error(`Invalid header line: ${line}`);\n\t\t}\n\t\tlet value = match[2];\n\t\twhile (true) {\n\t\t\tconst continueMatch = HEADER_CONTINUE_REGEX.exec(value);\n\t\t\tif (!continueMatch) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvalue = continueMatch[1];\n\t\t}\n\t\tconst key = match[1].toLowerCase();\n\t\tif (key === \"transfer-encoding\" && value.toLowerCase() === \"chunked\") {\n\t\t\tchunked = true;\n\t\t} else if (key === \"content-length\") {\n\t\t\tcontentLength = +value;\n\t\t}\n\t\theaders.append(match[1], value);\n\t}\n\treturn [headers, chunked, contentLength];\n}\n\nfunction streamBody(\n\treader: TextReader,\n\tchunked: boolean,\n\tcontentLength: number,\n): ReadableStream<Uint8Array> | null {\n\tif (!chunked && contentLength === 0) {\n\t\treturn null;\n\t}\n\tconst stream = new TransformStream<Uint8Array, Uint8Array>();\n\tstreamBodyFromReaderToWritable(\n\t\treader,\n\t\tstream.writable,\n\t\tchunked,\n\t\tcontentLength,\n\t);\n\treturn stream.readable;\n}\n\nasync function streamBodyFromReaderToWritable(\n\treader: TextReader,\n\twritableStream: WritableStream<Uint8Array>,\n\tchunked: boolean,\n\tcontentLength: number,\n) {\n\tconst writer = writableStream.getWriter();\n\ttry {\n\t\tif (chunked) {\n\t\t\twhile (true) {\n\t\t\t\tconst { done, value: line } = await reader.readLine();\n\t\t\t\tif (done) {\n\t\t\t\t\tthrow new Error(\"Unexpected end of stream\");\n\t\t\t\t}\n\t\t\t\tif (HEADER_REGEX.exec(line)) {\n\t\t\t\t\tawait reader.readLine();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tconst chunkSize = Number.parseInt(line, 16);\n\t\t\t\tif (!chunkSize) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlet bytesLeft = chunkSize;\n\t\t\t\twhile (bytesLeft > 0) {\n\t\t\t\t\tconst { done, value: bytes } = await reader.read(chunkSize);\n\t\t\t\t\tif (done) {\n\t\t\t\t\t\tthrow new Error(\"Unexpected end of stream\");\n\t\t\t\t\t}\n\t\t\t\t\tbytesLeft -= bytes.byteLength;\n\t\t\t\t\tawait writer.write(bytes);\n\t\t\t\t}\n\t\t\t\tawait reader.readLine();\n\t\t\t}\n\t\t} else {\n\t\t\tlet bytesLeft = contentLength;\n\t\t\twhile (bytesLeft > 0) {\n\t\t\t\tconst { done, value: bytes } = await reader.read(bytesLeft);\n\t\t\t\tif (done) {\n\t\t\t\t\tthrow new Error(\"Unexpected end of stream\");\n\t\t\t\t}\n\t\t\t\tbytesLeft -= bytes.byteLength;\n\t\t\t\tawait writer.write(bytes);\n\t\t\t}\n\t\t}\n\t} finally {\n\t\treader.releaseLock();\n\t\twriter.releaseLock();\n\t\twritableStream.close();\n\t}\n}\n\nexport type TextReader = ReturnType<typeof createTextReader>;\n\nexport function createTextReader(\n\treader: ReadableStreamDefaultReader<Uint8Array>,\n\tbufferSize = DEFAULT_BUFFER_SIZE,\n) {\n\tlet buffer = new Uint8Array(bufferSize);\n\tlet bufferOffset = 0;\n\tlet bufferLength = 0;\n\tlet doneReading = false;\n\n\tasync function tryFillTo(offset: number) {\n\t\tif (doneReading) {\n\t\t\treturn offset < bufferLength;\n\t\t}\n\t\twhile (offset >= bufferLength) {\n\t\t\tconst { done, value: bytes } = await reader.read();\n\t\t\tif (done) {\n\t\t\t\tdoneReading = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuffer = writeToUint8Array(buffer, bufferLength, bytes);\n\t\t\tbufferLength += bytes.byteLength;\n\t\t}\n\t\treturn offset < bufferLength;\n\t}\n\n\tasync function readLine(): Promise<ReadableStreamReadResult<string>> {\n\t\tlet index = bufferOffset;\n\t\tlet hasData = await tryFillTo(index);\n\t\twhile (hasData) {\n\t\t\tif (buffer[index] === NEWLINE) {\n\t\t\t\tconst prevIsReturn = buffer[index - 1] === RETURN;\n\t\t\t\tconst endIndex = prevIsReturn ? index - 1 : index;\n\t\t\t\tconst line = TEXT_DECODER.decode(buffer.slice(bufferOffset, endIndex));\n\t\t\t\tbufferOffset = index + 1;\n\t\t\t\treturn { done: false, value: line };\n\t\t\t}\n\t\t\tindex++;\n\t\t\tif (index >= bufferLength) {\n\t\t\t\thasData = await tryFillTo(index);\n\t\t\t}\n\t\t}\n\t\treturn { done: true };\n\t}\n\n\tasync function read(\n\t\tbyteCount: number,\n\t): Promise<ReadableStreamReadResult<Uint8Array>> {\n\t\tconst byteLength = bufferOffset + byteCount;\n\t\tawait tryFillTo(byteLength - 1);\n\t\tconst maxBytesToRead = Math.min(bufferLength - bufferOffset, byteCount);\n\t\tif (maxBytesToRead === 0) {\n\t\t\treturn { done: true };\n\t\t}\n\t\tconst bytes = buffer.slice(bufferOffset, bufferOffset + maxBytesToRead);\n\t\tbufferOffset += maxBytesToRead;\n\t\treturn { done: false, value: bytes };\n\t}\n\n\tfunction releaseLock() {\n\t\treader.releaseLock();\n\t}\n\n\treturn {\n\t\treadLine,\n\t\tread,\n\t\treleaseLock,\n\t};\n}\n\nexport function concatUint8Array(a: Uint8Array, b: Uint8Array) {\n\tconst bytes = new Uint8Array(a.byteLength + b.byteLength);\n\tbytes.set(a);\n\tbytes.set(b, a.byteLength);\n\treturn bytes;\n}\n\nexport function writeToUint8Array(\n\tbuffer: Uint8Array,\n\toffset: number,\n\tchunk: Uint8Array,\n): Uint8Array {\n\tif (chunk.byteLength >= buffer.byteLength - offset) {\n\t\tconst newBuffer = new Uint8Array(buffer.byteLength * 2);\n\t\tnewBuffer.set(buffer);\n\t\tnewBuffer.set(chunk, offset);\n\t\treturn newBuffer;\n\t}\n\tbuffer.set(chunk, offset);\n\treturn buffer;\n}\n\nexport async function readAll(\n\treader: ReadableStreamDefaultReader<Uint8Array>,\n): Promise<Uint8Array> {\n\ttry {\n\t\tconst { done, value: bytes } = await reader.read();\n\t\tif (done) {\n\t\t\treturn new Uint8Array();\n\t\t}\n\t\tlet result = bytes;\n\t\twhile (true) {\n\t\t\tconst { done, value: bytes } = await reader.read();\n\t\t\tif (done) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult = concatUint8Array(result, bytes);\n\t\t}\n\t\treturn result;\n\t} finally {\n\t\treader.releaseLock();\n\t}\n}\n"],"names":["DEFAULT_BUFFER_SIZE","HEADER_REGEX","HEADER_CONTINUE_REGEX","REQUEST_REGEX","RESPONSE_REGEX","NEWLINE","charCodeAt","RETURN","TEXT_ENCODER","TextEncoder","TEXT_DECODER","TextDecoder","HTTPRequest","Request","constructor","input","init","headersInit","headers","super","Headers","Object","defineProperty","this","value","writable","async","parseRequest","reader","mode","credentials","textReader","createTextReader","method","url","done","startLine","readLine","Error","match","exec","readRequestStartLine","chunked","contentLength","readHeaders","body","streamBody","duplex","parseResponse","statusCode","statusText","readResponseStartLine","Response","status","writeRequestOrResponse","writableStream","requestOrResponse","writer","getWriter","closed","request","response","write","encode","readAll","getReader","set","byteLength","key","entries","Number","parseInt","get","toLowerCase","releaseLock","pipeTo","close","line","continueMatch","append","stream","TransformStream","chunkSize","bytesLeft","bytes","read","streamBodyFromReaderToWritable","readable","bufferSize","buffer","Uint8Array","bufferOffset","bufferLength","doneReading","tryFillTo","offset","writeToUint8Array","index","hasData","endIndex","decode","slice","byteCount","maxBytesToRead","Math","min","concatUint8Array","a","b","chunk","newBuffer","result"],"mappings":"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"}