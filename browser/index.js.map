{"version":3,"file":"index.js","sources":["../src/http.ts"],"sourcesContent":["export const DEFAULT_BUFFER_SIZE = 4096;\n\nexport const HEADER_REGEX = /^([^: \\t]+):[ \\t]*((?:.*[^ \\t])|)/;\nexport const HEADER_CONTINUE_REGEX = /^[ \\t]+(.*[^ \\t])/;\nexport const REQUEST_REGEX = /^([A-Z-]+) ([^ ]+) HTTP\\/(\\d)\\.(\\d)$/;\nexport const RESPONSE_REGEX = /^HTTP\\/(\\d)\\.(\\d) (\\d{3}) ?(.*)$/;\n\nexport const NEWLINE = \"\\n\".charCodeAt(0);\nexport const RETURN = \"\\r\".charCodeAt(0);\n\nexport const TEXT_ENCODER = new TextEncoder();\nexport const TEXT_DECODER = new TextDecoder();\n\nexport class HTTPRequest extends Request {\n  constructor(input: RequestInfo | URL, init?: RequestInit) {\n    const headersInit = init?.headers;\n    super(input, init);\n    if (headersInit) {\n      const headers = new Headers(headersInit);\n      Object.defineProperty(this, \"headers\", {\n        value: headers,\n        writable: false,\n      });\n    }\n  }\n}\n\nexport async function parseRequest(\n  reader: ReadableStreamDefaultReader<Uint8Array>,\n  init: RequestInit = {\n    mode: \"same-origin\",\n    credentials: \"include\",\n  }\n): Promise<Request> {\n  const textReader = createTextReader(reader);\n  const [method, url] = await readRequestStartLine(textReader);\n  const [headers, chunked, contentLength] = await readHeaders(textReader);\n  const body = streamBody(textReader, chunked, contentLength);\n  return new HTTPRequest(url, {\n    ...init,\n    method,\n    headers,\n    body,\n    // @ts-expect-error\n    duplex: \"half\",\n  });\n}\n\nexport async function parseResponse(\n  reader: ReadableStreamDefaultReader<Uint8Array>\n) {\n  const textReader = createTextReader(reader);\n  const [statusCode, statusText] = await readResponseStartLine(textReader);\n  const [headers, chunked, contentLength] = await readHeaders(textReader);\n  const body = streamBody(textReader, chunked, contentLength);\n  return new Response(body, {\n    status: statusCode,\n    statusText: statusText,\n    headers,\n  });\n}\n\nexport async function writeRequestOrResponse(\n  writableStream: WritableStream<Uint8Array>,\n  requestOrResponse: Request | Response\n) {\n  const writer = writableStream.getWriter();\n  let closed = false;\n  try {\n    const [request, response] =\n      requestOrResponse instanceof Request\n        ? [requestOrResponse, null]\n        : [null, requestOrResponse];\n    if (request) {\n      await writer.write(\n        TEXT_ENCODER.encode(`${request.method} ${request.url} HTTP/1.1\\r\\n`)\n      );\n    } else {\n      await writer.write(\n        TEXT_ENCODER.encode(\n          `HTTP/1.1 ${response.status} ${response.statusText}\\r\\n`\n        )\n      );\n    }\n    const headers = new Headers(requestOrResponse.headers) as Headers & {\n      entries(): IterableIterator<[string, string]>;\n    };\n    if (requestOrResponse.body) {\n      if (request) {\n        const body = await readAll(requestOrResponse.body.getReader());\n\n        headers.set(\"Content-Length\", `${body.byteLength}`);\n\n        for (const [key, value] of headers.entries()) {\n          await writer.write(TEXT_ENCODER.encode(`${key}: ${value}\\r\\n`));\n        }\n        await writer.write(TEXT_ENCODER.encode(\"\\r\\n\"));\n        await writer.write(body);\n      } else {\n        const contentLength = Number.parseInt(\n          headers.get(\"Content-Length\") || \"0\",\n          10\n        );\n        const chunked =\n          headers.get(\"Transfer-Encoding\")?.toLowerCase() === \"chunked\";\n\n        for (const [key, value] of headers.entries()) {\n          await writer.write(TEXT_ENCODER.encode(`${key}: ${value}\\r\\n`));\n        }\n        await writer.write(TEXT_ENCODER.encode(\"\\r\\n\"));\n        writer.releaseLock();\n\n        await streamBody(\n          createTextReader(requestOrResponse.body.getReader()),\n          chunked,\n          contentLength\n        )?.pipeTo(writableStream);\n\n        closed = true;\n      }\n    } else {\n      for (const [key, value] of headers.entries()) {\n        await writer.write(TEXT_ENCODER.encode(`${key}: ${value}\\r\\n`));\n      }\n      await writer.write(TEXT_ENCODER.encode(\"\\r\\n\"));\n    }\n  } finally {\n    if (!closed) {\n      writer.releaseLock();\n      writableStream.close();\n    }\n  }\n}\n\nasync function readRequestStartLine(\n  reader: TextReader\n): Promise<\n  [method: string, url: string, versionMajor: number, versionMinor: number]\n> {\n  const { done, value: startLine } = await reader.readLine();\n  if (done) {\n    throw new Error(\"Unexpected end of request\");\n  }\n  const match = REQUEST_REGEX.exec(startLine);\n  if (!match) {\n    throw new Error(`Invalid request line: ${startLine}`);\n  }\n  return [match[1], match[2], +match[3], +match[4]];\n}\n\nasync function readResponseStartLine(\n  reader: TextReader\n): Promise<\n  [\n    statusCode: number,\n    statusText: string,\n    versionMajor: number,\n    versionMinor: number\n  ]\n> {\n  const { done, value: startLine } = await reader.readLine();\n  if (done) {\n    throw new Error(\"Unexpected end of request\");\n  }\n  const match = RESPONSE_REGEX.exec(startLine);\n  if (!match) {\n    throw new Error(`Invalid response line: ${startLine}`);\n  }\n  return [+match[3], match[4], +match[1], +match[2]];\n}\n\nasync function readHeaders(\n  reader: TextReader\n): Promise<[headers: Headers, chunked: boolean, contentLength: number]> {\n  const headers = new Headers();\n  let chunked = false;\n  let contentLength = 0;\n  while (true) {\n    const { done, value: line } = await reader.readLine();\n    if (done) {\n      throw new Error(\"Unexpected end of headers\");\n    }\n    if (line === \"\") {\n      break;\n    }\n    const match = HEADER_REGEX.exec(line);\n    if (!match) {\n      throw new Error(`Invalid header line: ${line}`);\n    }\n    let value = match[2];\n    while (true) {\n      const continueMatch = HEADER_CONTINUE_REGEX.exec(value);\n      if (!continueMatch) {\n        break;\n      }\n      value = continueMatch[1];\n    }\n    const key = match[1].toLowerCase();\n    if (key === \"transfer-encoding\" && value.toLowerCase() === \"chunked\") {\n      chunked = true;\n    } else if (key === \"content-length\") {\n      contentLength = +value;\n    }\n    headers.append(match[1], value);\n  }\n  return [headers, chunked, contentLength];\n}\n\nfunction streamBody(\n  reader: TextReader,\n  chunked: boolean,\n  contentLength: number\n): ReadableStream<Uint8Array> | null {\n  if (!chunked && contentLength === 0) {\n    return null;\n  }\n  const stream = new TransformStream<Uint8Array, Uint8Array>();\n  streamBodyFromReaderToWritable(\n    reader,\n    stream.writable,\n    chunked,\n    contentLength\n  );\n  return stream.readable;\n}\n\nasync function streamBodyFromReaderToWritable(\n  reader: TextReader,\n  writableStream: WritableStream<Uint8Array>,\n  chunked: boolean,\n  contentLength: number\n) {\n  const writer = writableStream.getWriter();\n  try {\n    if (chunked) {\n      while (true) {\n        const { done, value: line } = await reader.readLine();\n        if (done) {\n          throw new Error(\"Unexpected end of stream\");\n        }\n        if (HEADER_REGEX.exec(line)) {\n          await reader.readLine();\n          break;\n        }\n        const chunkSize = Number.parseInt(line, 16);\n        if (!chunkSize) {\n          break;\n        }\n        let bytesLeft = chunkSize;\n        while (bytesLeft > 0) {\n          const { done, value: bytes } = await reader.read(chunkSize);\n          if (done) {\n            throw new Error(\"Unexpected end of stream\");\n          }\n          bytesLeft -= bytes.byteLength;\n          await writer.write(bytes);\n        }\n        await reader.readLine();\n      }\n    } else {\n      let bytesLeft = contentLength;\n      while (bytesLeft > 0) {\n        const { done, value: bytes } = await reader.read(bytesLeft);\n        if (done) {\n          throw new Error(\"Unexpected end of stream\");\n        }\n        bytesLeft -= bytes.byteLength;\n        await writer.write(bytes);\n      }\n    }\n  } finally {\n    reader.releaseLock();\n    writer.releaseLock();\n    writableStream.close();\n  }\n}\n\nexport type TextReader = ReturnType<typeof createTextReader>;\n\nexport function createTextReader(\n  reader: ReadableStreamDefaultReader<Uint8Array>,\n  bufferSize = DEFAULT_BUFFER_SIZE\n) {\n  let buffer: Uint8Array = new Uint8Array(bufferSize);\n  let bufferOffset = 0;\n  let bufferLength = 0;\n  let doneReading = false;\n\n  async function tryFillTo(offset: number) {\n    if (doneReading) {\n      return offset < bufferLength;\n    }\n    while (offset >= bufferLength) {\n      const { done, value: bytes } = await reader.read();\n      if (done) {\n        doneReading = true;\n        break;\n      }\n      buffer = writeToUint8Array(buffer, bufferLength, bytes);\n      bufferLength += bytes.byteLength;\n    }\n    return offset < bufferLength;\n  }\n\n  async function readLine(): Promise<ReadableStreamReadResult<string>> {\n    let index = bufferOffset;\n    let hasData = await tryFillTo(index);\n    while (hasData) {\n      if (buffer[index] === NEWLINE) {\n        const prevIsReturn = buffer[index - 1] === RETURN;\n        const endIndex = prevIsReturn ? index - 1 : index;\n        const line = TEXT_DECODER.decode(buffer.slice(bufferOffset, endIndex));\n        bufferOffset = index + 1;\n        return { done: false, value: line };\n      }\n      index++;\n      if (index >= bufferLength) {\n        hasData = await tryFillTo(index);\n      }\n    }\n    return { done: true };\n  }\n\n  async function read(\n    byteCount: number\n  ): Promise<ReadableStreamReadResult<Uint8Array>> {\n    const byteLength = bufferOffset + byteCount;\n    await tryFillTo(byteLength - 1);\n    const maxBytesToRead = Math.min(bufferLength - bufferOffset, byteCount);\n    if (maxBytesToRead === 0) {\n      return { done: true };\n    }\n    const bytes = buffer.slice(bufferOffset, bufferOffset + maxBytesToRead);\n    bufferOffset += maxBytesToRead;\n    return { done: false, value: bytes };\n  }\n\n  function releaseLock() {\n    reader.releaseLock();\n  }\n\n  return {\n    readLine,\n    read,\n    releaseLock,\n  };\n}\n\nexport function concatUint8Array(a: Uint8Array, b: Uint8Array) {\n  const bytes = new Uint8Array(a.byteLength + b.byteLength);\n  bytes.set(a);\n  bytes.set(b, a.byteLength);\n  return bytes;\n}\n\nexport function writeToUint8Array(\n  buffer: Uint8Array,\n  offset: number,\n  chunk: Uint8Array\n): Uint8Array {\n  if (chunk.byteLength >= buffer.byteLength - offset) {\n    const newBuffer = new Uint8Array(buffer.byteLength * 2);\n    newBuffer.set(buffer);\n    newBuffer.set(chunk, offset);\n    return newBuffer;\n  }\n  buffer.set(chunk, offset);\n  return buffer;\n}\n\nexport async function readAll(\n  reader: ReadableStreamDefaultReader<Uint8Array>\n): Promise<Uint8Array> {\n  try {\n    const { done, value: bytes } = await reader.read();\n    if (done) {\n      return new Uint8Array();\n    }\n    let result = bytes;\n    while (true) {\n      const { done, value: bytes } = await reader.read();\n      if (done) {\n        break;\n      }\n      result = concatUint8Array(result, bytes);\n    }\n    return result;\n  } finally {\n    reader.releaseLock();\n  }\n}\n"],"names":["HEADER_REGEX","HEADER_CONTINUE_REGEX","REQUEST_REGEX","RESPONSE_REGEX","NEWLINE","charCodeAt","RETURN","TEXT_ENCODER","TextEncoder","TEXT_DECODER","TextDecoder","HTTPRequest","Request","constructor","input","init","headersInit","headers","super","Headers","Object","defineProperty","this","value","writable","async","parseRequest","reader","mode","credentials","textReader","createTextReader","method","url","done","startLine","readLine","Error","match","exec","readRequestStartLine","chunked","contentLength","readHeaders","body","streamBody","duplex","parseResponse","statusCode","statusText","readResponseStartLine","Response","status","writeRequestOrResponse","writableStream","requestOrResponse","writer","getWriter","closed","request","response","write","encode","readAll","getReader","set","byteLength","key","entries","Number","parseInt","get","toLowerCase","releaseLock","pipeTo","close","line","continueMatch","append","stream","TransformStream","chunkSize","bytesLeft","bytes","read","streamBodyFromReaderToWritable","readable","bufferSize","buffer","Uint8Array","bufferOffset","bufferLength","doneReading","tryFillTo","offset","writeToUint8Array","index","hasData","endIndex","decode","slice","byteCount","maxBytesToRead","Math","min","concatUint8Array","a","b","chunk","newBuffer","result"],"mappings":"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"}