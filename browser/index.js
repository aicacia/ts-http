const e=4096,t=/^([^: \t]+):[ \t]*((?:.*[^ \t])|)/,n=/^[ \t]+(.*[^ \t])/,r=/^([A-Z-]+) ([^ ]+) HTTP\/(\d)\.(\d)$/,a=/^HTTP\/(\d)\.(\d) (\d{3}) ?(.*)$/,o="\n".charCodeAt(0),i="\r".charCodeAt(0),s=new TextEncoder,c=new TextDecoder;class d extends Request{constructor(e,t){const n=t?.headers;if(super(e,t),n){const e=new Headers(n);Object.defineProperty(this,"headers",{value:e,writable:!1})}}}async function w(e,t={mode:"same-origin",credentials:"include"}){const n=y(e),[a,o]=await async function(e){const{done:t,value:n}=await e.readLine();if(t)throw new Error("Unexpected end of request");const a=r.exec(n);if(!a)throw new Error(`Invalid request line: ${n}`);return[a[1],a[2],+a[3],+a[4]]}(n),[i,s,c]=await l(n),w=h(n,s,c);return new d(o,{...t,method:a,headers:i,body:w,duplex:"half"})}async function f(e){const t=y(e),[n,r]=await async function(e){const{done:t,value:n}=await e.readLine();if(t)throw new Error("Unexpected end of request");const r=a.exec(n);if(!r)throw new Error(`Invalid response line: ${n}`);return[+r[3],r[4],+r[1],+r[2]]}(t),[o,i,s]=await l(t),c=h(t,i,s);return new Response(c,{status:n,statusText:r,headers:o})}async function u(e,t){const n=e.getWriter();let r=!1;try{const[a,o]=t instanceof Request?[t,null]:[null,t];a?await n.write(s.encode(`${a.method} ${a.url} HTTP/1.1\r\n`)):await n.write(s.encode(`HTTP/1.1 ${o.status} ${o.statusText}\r\n`));const i=new Headers(t.headers);if(t.body)if(a){const e=await g(t.body.getReader());i.set("Content-Length",`${e.byteLength}`);for(const[e,t]of i.entries())await n.write(s.encode(`${e}: ${t}\r\n`));await n.write(s.encode("\r\n")),await n.write(e)}else{const a=Number.parseInt(i.get("Content-Length")||"0",10),o="chunked"===i.get("Transfer-Encoding")?.toLowerCase();for(const[e,t]of i.entries())await n.write(s.encode(`${e}: ${t}\r\n`));await n.write(s.encode("\r\n")),n.releaseLock(),await(h(y(t.body.getReader()),o,a)?.pipeTo(e)),r=!0}else{for(const[e,t]of i.entries())await n.write(s.encode(`${e}: ${t}\r\n`));await n.write(s.encode("\r\n"))}}finally{r||(n.releaseLock(),e.close())}}async function l(e){const r=new Headers;let a=!1,o=0;for(;;){const{done:i,value:s}=await e.readLine();if(i)throw new Error("Unexpected end of headers");if(""===s)break;const c=t.exec(s);if(!c)throw new Error(`Invalid header line: ${s}`);let d=c[2];for(;;){const e=n.exec(d);if(!e)break;d=e[1]}const w=c[1].toLowerCase();"transfer-encoding"===w&&"chunked"===d.toLowerCase()?a=!0:"content-length"===w&&(o=+d),r.append(c[1],d)}return[r,a,o]}function h(e,n,r){if(!n&&0===r)return null;const a=new TransformStream;return async function(e,n,r,a){const o=n.getWriter();try{if(r)for(;;){const{done:n,value:r}=await e.readLine();if(n)throw new Error("Unexpected end of stream");if(t.exec(r)){await e.readLine();break}const a=Number.parseInt(r,16);if(!a)break;let i=a;for(;i>0;){const{done:t,value:n}=await e.read(a);if(t)throw new Error("Unexpected end of stream");i-=n.byteLength,await o.write(n)}await e.readLine()}else{let t=a;for(;t>0;){const{done:n,value:r}=await e.read(t);if(n)throw new Error("Unexpected end of stream");t-=r.byteLength,await o.write(r)}}}finally{e.releaseLock(),o.releaseLock(),n.close()}}(e,a.writable,n,r),a.readable}function y(t,n=e){let r=new Uint8Array(n),a=0,s=0,d=!1;async function w(e){if(d)return e<s;for(;e>=s;){const{done:e,value:n}=await t.read();if(e){d=!0;break}r=b(r,s,n),s+=n.byteLength}return e<s}return{readLine:async function(){let e=a,t=await w(e);for(;t;){if(r[e]===o){const t=r[e-1]===i?e-1:e,n=c.decode(r.slice(a,t));return a=e+1,{done:!1,value:n}}e++,e>=s&&(t=await w(e))}return{done:!0}},read:async function(e){const t=a+e;await w(t-1);const n=Math.min(s-a,e);if(0===n)return{done:!0};const o=r.slice(a,a+n);return a+=n,{done:!1,value:o}},releaseLock:function(){t.releaseLock()}}}function L(e,t){const n=new Uint8Array(e.byteLength+t.byteLength);return n.set(e),n.set(t,e.byteLength),n}function b(e,t,n){if(n.byteLength>=e.byteLength-t){const r=new Uint8Array(2*e.byteLength);return r.set(e),r.set(n,t),r}return e.set(n,t),e}async function g(e){try{const{done:t,value:n}=await e.read();if(t)return new Uint8Array;let r=n;for(;;){const{done:t,value:n}=await e.read();if(t)break;r=L(r,n)}return r}finally{e.releaseLock()}}export{d as HTTPRequest,L as concatUint8Array,y as createTextReader,w as parseRequest,f as parseResponse,g as readAll,u as writeRequestOrResponse,b as writeToUint8Array};
//# sourceMappingURL=index.js.map
